# üìù IR Builder Documentation (Phase 2)

This documentation describes the expected input syntax for the compiler front-end and the resulting Intermediate Representation (IR) structure generated by the `buildUntiledIR()` function.

## 1\. Input Syntax Specification

The $\text{IR}$ Builder accepts a single string input in a **fixed, structured format**. The parser is highly specific and relies on this exact structure to function correctly.

### Required Format

The input must contain two main sections, `LOOPS:` and `BODY:`, separated by newline or space, followed by the specific definitions.

```markdown
LOOPS: [Loop_Def_1], [Loop_Def_2], ...
BODY: [Target_Access] = [RHS_Expression]
```

### 1.1. LOOPS Section

The $\text{LOOPS}$ section defines the entire loop nest structure, from the outermost to the innermost loop, separated by commas.

| Component | Format | Example |
| :--- | :--- | :--- |
| **Loop Definition** | `variable=LB:UB:STEP` | `i=0:N:1` |
| **`variable`** | The loop index variable name (e.g., `i`, `j`, `k`). | |
| **`LB` (Lower Bound)** | The start value (e.g., `0`). | |
| **`UB` (Upper Bound)** | The end value. Must be a symbolic $\text{Variable}$ (e.g., `N`, `M`). | |
| **`STEP`** | The increment value (e.g., `1`). | |

**Crucial Logic:** The loops must be listed **from the outermost to the innermost** (e.g., `i` then `j` then `k`). The parser iterates over this list backward to correctly build the nested $\text{IR}$ structure.

### 1.2. BODY Section

The $\text{BODY}$ section defines the single assignment statement within the innermost loop.

| Component | Format | Example |
| :--- | :--- | :--- |
| **Target Access** | `TENSOR_NAME[idx1, idx2, ...]` | `C[i, j]` |
| **RHS Expression** | An expression using array accesses (`+` and `*` operators). | `A[i, k] * B[k, j]` |

## 2\. Supported Operations and Assumptions

The parser makes strict assumptions about the complexity of the input:

| Element | Supported | Assumptions/Limitations |
| :--- | :--- | :--- |
| **Array Tensors** | $\text{A}, \text{B}, \text{C}$ | The parser only recognizes tensors named **A**, **B**, and **C** (due to the `TensorMap` initialization). |
| **Operators** | $\text{Addition}$ (`+`), $\text{Multiplication}$ (`*`) | The parser only supports these two binary operators. |
| **Precedence** | **Additive** over **Multiplicative** | The parser is hardcoded to parse $\text{Addition}$ (`+`) first, then $\text{Multiplication}$ (`*`). It currently only handles basic grouping via parentheses on the $\text{RHS}$ expression. |
| **Indexing** | Simple $\text{Variable}$ index only | Array indices (`idx1`, `idx2`, ...) must be single $\text{Variable}$ names (e.g., `i` or `j`). Complex index expressions like `A[i + 1]` are **not supported**. |
| **Assignment Target** | Tensor $\text{Store}$ only | The $\text{LHS}$ of the body **must** be a $\text{Tensor}$ access (e.g., `C[i, j]`). Assignment to local $\text{ScalarRef}$ variables is not supported by the parser input. |

## 3\. Example Programs

| Program Name | Input String |
| :--- | :--- |
| **Matrix Addition (2D)** | `LOOPS: i=0:N:1, j=0:M:1\nBODY: C[i, j] = A[i, j] + B[i, j]` |
| **Matrix Multiplication Core (3D)** | `LOOPS: i=0:N:1, j=0:M:1, k=0:K:1\nBODY: C[i, j] = C[i, j] + (A[i, k] * B[k, j])` |
| **Matrix Transposition (2D)** | `LOOPS: i=0:N:1, j=0:M:1\nBODY: C[i, j] = A[j, i]` |

## 4\. Output IR Structure

The `buildUntiledIR()` function returns a `std::unique_ptr<IRNode>` pointing to the root of the constructed IR tree.

The resulting $\text{IR}$ structure will always be a perfectly nested hierarchy:

$$\text{Loop}_1 \to \text{Loop}_2 \to \dots \to \text{Loop}_N \to \text{Assign}$$

The $\text{Assign}$ node will contain the full expression tree:

$$\text{Assign}(\text{Store}(\text{Target}), \text{ValueExpression})$$

  * **Root:** The outermost $\text{Loop}$ (e.g., the $\text{i}$ loop).
  * **Leaves:** $\text{Const}$ and $\text{Variable}$ nodes used in bounds and array indices.
  * **Target:** A $\text{Store}$ node, representing the $\text{LHS}$ array access.
  * **Value:** A tree of $\text{Add}$ / $\text{Mul}$ nodes, rooted by the last operator parsed in the $\text{RHS}$.